---
title: "**QDNAseq**"
author: "Michael Bell,  15002484" 
date: "05/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(QDNAseq)
library(tidyverse)
```

# **Quantitative DNA Sequencing for Chromosomal Aberrations**
## **QDNAseq R Package**

## **Contents:**  
**1:** Introduction  
\ **1.1:** Chromosomal Aberrations  
\ **1.2:**   
\ **1.3:**  
\ **1.4:**  
**2:** Running QDNAseq  
\ **2.1:** Bin Annotations  
\ **2.2:** Processing BAM Files  
\ **2.3:** Downstream Analyses
**3:** Sex Chromosome Processing
\

## **1: Introduction:**
Scheinin et al. (2014) developed the QDNAseq pipeline to help improve the detection of DNA copy number aberrations from whole-genome sequencing (WGS). The focus of the study was to improve analysis and quantification of the challenges that are presented by WGS; this includes reference genome errors, sequence completions, repeat sequences, polymorphisms, variability in sample quality and procedure bias.  

## **1.1: Chromosomal Aberrations:**  
Chromosomal aberrations are defined as a change within either the structure or number of a chromosome. Most typical chromosomal aberrations are considered to be aneuploids; meaning they contain or are missing a number of chromosomes (e.g trisomy and monosomy) (Abhishek et al. (2018). 

## **1.2: **

## **1.3: **

## **1.4: **

## **2: Running QDNAseq**

### **2.1: Bin Annotations**  
```{r Bin Annotations}
bins <- getBinAnnotations(binSize=15)
bins
```  

### **2.2: Processing Bam Files**  

### _**Obtaining Data**_
```{r Obtaining Data}
data(LGG150)
readCounts <- (LGG150)
readCounts
```  

### _**Read Count Plot**_
```{r LGG150 Read Count Plot}
plot(readCounts, logTransform=FALSE, ylim=c(-50, 200))
```  

### _**Median Read Count Plot**_
```{r LGG150 Median Read Count Plot}
readCountsFiltered <- applyFilters(readCounts, residual=TRUE, blacklist=TRUE)

isobarPlot(readCountsFiltered)
```  

### _**Read Count Noise Plot**_
```{r LGG150 Read Count Noise Plot}
noisePlot(readCountsFiltered)
```  

### _**Copy Number Filtering**_
```{r LGG150 Copy Number Filtering}
copyNumbers <- correctBins(readCountsFiltered)

copyNumbers

copyNumbersNormalized <- normalizeBins(copyNumbers)

copyNumbersSmooth <- smoothOutlierBins(copyNumbersNormalized)
```  

### _**Filtered Read Count Plot**_
```{r LGG150 Filtered Read Count Plot}
plot(copyNumbersSmooth)
```  

### _**Exporting Filtered Read Counts**_
```{r Exporting Filtered Read Counts}
exportBins(copyNumbersSmooth, file="LGG150.txt")

exportBins(copyNumbersSmooth, file="LGG150.igv", format="igv")

exportBins(copyNumbersSmooth, file="LGG150.bed", format="bed")
```  

## **2.3: Downstream Analysis**  

### _**Read Count Segmenting**_
```{r LGG150 Read Count Segmenting}
copyNumbersSegmented <- segmentBins(copyNumbersSmooth, transformFun="sqrt")

copyNumbersSegmented <- normalizeSegmentedBins(copyNumbersSegmented)
```  

### _**Segmented Read Count Plot**_
```{r LGG150 Segmented Read Count Plot}
plot(copyNumbersSegmented)
```  

### _**Called Read Count Plot**_
```{r LGG150 Called Read Count Plot, result=FALSE, warning=FALSE, message=FALSE}
copyNumbersCalled <- callBins(copyNumbersSegmented)

plot(copyNumbersCalled)
```  

### _**Called Count Extraction to VCF and SEG Files**_
```{r LGG150 Called Count Extraction to VCF and SEG Files}
exportBins(copyNumbersCalled, "copyNumbersCalled.vcf")

exportBins(copyNumbersCalled, "copyNumbersCalled.seg")
```  

### _**CGHcall Conversion**_
```{r CGHcall Conversion}
cgh <- makeCgh(copyNumbersCalled)

cgh
```  

## **2.4 Parallel Comparison**  

### _**Parallel Computation**_  
_**QDNAseq**_ can allow for parallel computing using the _**future**_ package. In order to do this and appropriate plan must be selected. _**QDNAseq**_ currently includes estimateCorrection(), segmentBins(), createBins() and calculateBlacklist() for parallel processing. It also includes binReadcounts() but this only parallelises by chromosome when chunkSize is used. The default argument method="CGHcall" can be used for parallel computation using the function callBins() or CGHcall(). However the number of processes to use needs to be specified with the argument ncpus.  

### _**Non-Parallel Processing**_  
The Default is to use single-core processing via "sequential" futres. This is set by: 
```{r Non-Parallel Processing}
future::plan("sequential")
```  

### _**Parallel Processing on the Current Machine and Adhoc Machine**_  

Connecting to an Adhoc machine using multiple R sessions the following code or similar should be used: 
```{}
cl <- future::makeClusterPSOCK(...)
future::plan("cluster", cluster=cl)
```

## **3: Sex Chromosome Processing**  
_**QDNAseq**_ automatically ignores sex chromosomes by default. in order for them to be included in the analysis, the function applyFilters() should be run with the argument chromosomes=NA (includes both X and Y) or chromsomes="Y"/chromsomes="X" to include X or Y respectively.   
This would also affect the calculation of LOESS and should be counteracted by using the estimateCorrection() function. The process should be: Filter Sex Chromosomes, run estimateCorrection() and reverse the sex chromosome filtering.  

### _**Sex Chromosome QDNAseq**_  
```{}
readCounts <- binReadCounts(getBinAnnotations(15))  
readCounts <- applyFilters(readCounts)  
readCounts <- estimateCorrection(readCounts)  
readCounts <- applyFilters(readCounts, chromosomes=NA)  
copyNumbers <- correctBins(readCounts)
```
## **Discussion**
